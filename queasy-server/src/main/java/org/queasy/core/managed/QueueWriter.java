package org.queasy.core.managed;

import com.google.common.annotations.VisibleForTesting;
import io.dropwizard.lifecycle.Managed;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultSetAccumulator;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.StatementContext;
import org.queasy.core.config.QueueConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * @author saroskar
 * Created on: 2021-03-22
 */
public final class QueueWriter implements Managed, Runnable {

    private QueueConfiguration queueConfiguration;
    private final Jdbi jdbi;
    private final ArrayBlockingQueue<String[]> queue;
    private final String insertSQL;
    private final LastAutoGeneratedIdFinder generatedIdFinder;
    private final long writeTimeout;
    private Thread writerThread;

    private volatile boolean shutdownFlag;
    private volatile long currentId;

    private static final Logger logger = LoggerFactory.getLogger(QueueWriter.class);


    public QueueWriter(final QueueConfiguration queueConfiguration, final Jdbi jdbi) {
        this.queueConfiguration = queueConfiguration;
        this.jdbi = jdbi;
        queue = new ArrayBlockingQueue<>(queueConfiguration.getRingBufferSize());
        insertSQL = "INSERT INTO " + queueConfiguration.getTableName() + " (qname, type, ts, mesg) VALUES (?, ?, ?, ?)";
        generatedIdFinder = new LastAutoGeneratedIdFinder(queueConfiguration.getAutoGeneratedIdColumnName());
        writeTimeout = queueConfiguration.getWriteTimeout().toMilliseconds();
    }

    public long getCurrentId() {
        return currentId;
    }

    @Override
    public void start() {
        shutdownFlag = false;
        writerThread = new Thread(this, "queasy-writer");
        writerThread.start();
    }

    @Override
    public void stop() {
        shutdownFlag = true;
        writerThread.interrupt();
    }

    @VisibleForTesting
    public void join() throws InterruptedException {
        writerThread.join();
    }

    @VisibleForTesting
    public void drainQueue() {
        queue.clear();
    }

    public boolean publish(final String[] message) throws InterruptedException {
        return queue.offer(message, writeTimeout, TimeUnit.MILLISECONDS);
    }

    public void run() {
        while (!shutdownFlag) {
            try (final Handle handle = jdbi.open()) {
                PreparedBatch batch = null;
                long ts = 0;
                int count = 0;

                String[] message = queue.take();
                while (message != null) {
                    if (count == 0) {
                        handle.begin();
                        batch = handle.prepareBatch(insertSQL);
                        ts = System.currentTimeMillis();
                    }

                    batch.bind(0, message[0])   //qname
                            .bindNull(1, Types.VARCHAR) //type
                            .bind(2, ts)
                            .bind(3, message[1])
                            .add();

                    count++;
                    message = queue.poll();

                    if (count >= queueConfiguration.getInsertBatchSize() || message == null) {
                        final long newId = batch
                                .executeAndReturnGeneratedKeys("rowid")
                                .reduceResultSet(0L, generatedIdFinder);
                        handle.commit();
                        currentId = newId;
                        count = 0;
                    }
                }
            }
            catch (InterruptedException ex) {
                //Check shutdown flag at the top of the loop
                logger.warn("Queue writer was interrupted");
            }
            catch (Exception ex) {
                logger.error("Queue writer caught exception:", ex);
            }
        }
    }


    private static final class LastAutoGeneratedIdFinder implements ResultSetAccumulator<Long> {
        private final String autoGeneratedIdColumnName;

        public LastAutoGeneratedIdFinder(final String autoGeneratedIdColumnName) {
            this.autoGeneratedIdColumnName = autoGeneratedIdColumnName;
        }

        @Override
        public Long apply(final Long previous, final ResultSet rs, final StatementContext ctx) throws SQLException {
            final Long id = rs.getLong(autoGeneratedIdColumnName);
            return id.compareTo(previous) > 0 ? id : previous;
        }
    }

}
